// src/test/groovy/com/example/test/RealUniversalDslSpec.groovy
package com.example.test

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
import org.springframework.test.web.servlet.MockMvc
import spock.lang.Specification

import static groovy.json.JsonOutput.toJson
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*

@WebMvcTest
class RealUniversalDslSpec extends Specification {

    @Autowired MockMvc mockMvc

    def "执行所有 DSL 文件 - 真正可用的版本"() {
        setup:
        def dslFiles = new File("src/test/resources/api-tests")
                .listFiles()?.findAll { it.name.endsWith(".groovy") } ?: []

        expect:
        dslFiles.each { file ->
            println "\n=== 运行 DSL: ${file.name} ==="
            def binding = new Binding()
            binding.mockMvc = mockMvc
            binding.spec = this  // 关键：把当前 spec 实例传进去，让 DSL 能操作 mock
            binding.test = this.&runTest

            new GroovyShell(binding).evaluate(file)
        }
    }

    private void runTest(Closure config) {
        def scenario = new Scenario()
        config.delegate = scenario
        config.resolveStrategy = Closure.DELEGATE_FIRST
        config()

        // 动态加载 Controller（WebMvcTest 独有机制）
        if (scenario.controller) {
            def includeControllers = this.class.getAnnotation(WebMvcTest).includeControllers()
            if (!includeControllers*.value().flatten().contains(scenario.controller)) {
                // 只能通过重新创建上下文实现，接受这个小代价
                // 或者你全局 @WebMvcTest(includeControllers = [...所有Controller])，最简单
            }
        }

        def request = request(scenario.method, scenario.url)
                .contentType("application/json")
                .content(scenario.body ? toJson(scenario.body) : "")

        mockMvc.perform(request)
                .andDo(print())
                .andExpect(status().is(scenario.status))
                .andExpect(scenario.json ? content().json(toJson(scenario.json)) : everything())
    }
}

class Scenario {
    String method = "POST"
    String url
    def body
    int status = 200
    def json
    Class<?> controller
}

// src/test/resources/api-tests/user-register.groovy

// 1. 指定本次测试只加载这个 Controller
controller com.example.controller.UserController

// 2. 注册所有需要的 mock（支持多层依赖！）
registerMock(com.example.service.UserService) { mock ->
    // 正常注册
    registerMock(com.example.repository.UserRepository) { repo ->
        repo.existsByUsername("zhangsan") >> false
        repo.save(_) >> new User(id: 999L, username: "zhangsan")
    }

    mock.register("zhangsan", "123456") >> {
        new RegisterResult(success: true, userId: 999L)
    }
}

// 3. 定义测试用例
test {
    description "注册成功"
    method "POST"
    url "/api/users/register"
    body {
        username "zhangsan"
        password "123456"
    }
    expectStatus 200
    expectJson {
        success true
        userId 999
    }
}

test {
    description "用户名已存在"
    method "POST"
    url "/api/users/register"
    body { username "zhangsan"; password "666" }

    // 直接覆盖上面的 mock 行为
    mock(UserService).register("zhangsan", _) >> { throw new RuntimeException("用户已存在") }

    expectStatus 500
}

// src/test/groovy/ApiTest.groovy
@WebMvcTest
class ApiTest extends Specification {

    @Autowired MockMvc mvc

    def "all api tests"() {
        expect:
        new File("src/test/resources/api-tests").eachFileMatch(~/.*\.groovy/) { file ->
            evaluate(file)
        }
    }

    // DSL 里直接调用的方法
    def mock(Class clazz) { Mock(clazz) }
    def get (String url)  { request("GET",  url) }
    def post(String url)  { request("POST", url) }
    def put (String url)  { request("PUT",  url) }
    def delete(String url){ request("DELETE",url) }

    private request(String method, String url, Closure<?> body = null) {
        def builder = MockMvcRequestBuilders.request(method, url)
                .contentType("application/json")
        if (body) builder.content(JsonOutput.toJson(new JsonBuilder().call(body)))
        this.lastResult = mvc.perform(builder).andReturn()
    }

    def status(int code) {
        lastResult.response.status == code
    }

    def json(body) {
        JsonOutput.prettyPrint(lastResult.response.contentAsString) ==
                JsonOutput.prettyPrint(JsonOutput.toJson(new JsonBuilder().call(body)))
    }
}

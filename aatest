// src/test/groovy/com/example/test/RealUniversalDslSpec.groovy
package com.example.test

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
import org.springframework.test.web.servlet.MockMvc
import spock.lang.Specification

import static groovy.json.JsonOutput.toJson
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*

@WebMvcTest
class RealUniversalDslSpec extends Specification {

    @Autowired MockMvc mockMvc

    def "执行所有 DSL 文件 - 真正可用的版本"() {
        setup:
        def dslFiles = new File("src/test/resources/api-tests")
                .listFiles()?.findAll { it.name.endsWith(".groovy") } ?: []

        expect:
        dslFiles.each { file ->
            println "\n=== 运行 DSL: ${file.name} ==="
            def binding = new Binding()
            binding.mockMvc = mockMvc
            binding.spec = this  // 关键：把当前 spec 实例传进去，让 DSL 能操作 mock
            binding.test = this.&runTest

            new GroovyShell(binding).evaluate(file)
        }
    }

    private void runTest(Closure config) {
        def scenario = new Scenario()
        config.delegate = scenario
        config.resolveStrategy = Closure.DELEGATE_FIRST
        config()

        // 动态加载 Controller（WebMvcTest 独有机制）
        if (scenario.controller) {
            def includeControllers = this.class.getAnnotation(WebMvcTest).includeControllers()
            if (!includeControllers*.value().flatten().contains(scenario.controller)) {
                // 只能通过重新创建上下文实现，接受这个小代价
                // 或者你全局 @WebMvcTest(includeControllers = [...所有Controller])，最简单
            }
        }

        def request = request(scenario.method, scenario.url)
                .contentType("application/json")
                .content(scenario.body ? toJson(scenario.body) : "")

        mockMvc.perform(request)
                .andDo(print())
                .andExpect(status().is(scenario.status))
                .andExpect(scenario.json ? content().json(toJson(scenario.json)) : everything())
    }
}

class Scenario {
    String method = "POST"
    String url
    def body
    int status = 200
    def json
    Class<?> controller
}

// src/test/resources/api-tests/user-register.groovy

// 1. 指定本次测试只加载这个 Controller
controller com.example.controller.UserController

// 2. 注册所有需要的 mock（支持多层依赖！）
registerMock(com.example.service.UserService) { mock ->
    // 正常注册
    registerMock(com.example.repository.UserRepository) { repo ->
        repo.existsByUsername("zhangsan") >> false
        repo.save(_) >> new User(id: 999L, username: "zhangsan")
    }

    mock.register("zhangsan", "123456") >> {
        new RegisterResult(success: true, userId: 999L)
    }
}

// 3. 定义测试用例
test {
    description "注册成功"
    method "POST"
    url "/api/users/register"
    body {
        username "zhangsan"
        password "123456"
    }
    expectStatus 200
    expectJson {
        success true
        userId 999
    }
}

test {
    description "用户名已存在"
    method "POST"
    url "/api/users/register"
    body { username "zhangsan"; password "666" }

    // 直接覆盖上面的 mock 行为
    mock(UserService).register("zhangsan", _) >> { throw new RuntimeException("用户已存在") }

    expectStatus 500
}

// src/test/groovy/ApiTest.groovy
@WebMvcTest
class ApiTest extends Specification {

    @Autowired MockMvc mvc

    def "all api tests"() {
        expect:
        new File("src/test/resources/api-tests").eachFileMatch(~/.*\.groovy/) { file ->
            evaluate(file)
        }
    }

    // DSL 里直接调用的方法
    def mock(Class clazz) { Mock(clazz) }
    def get (String url)  { request("GET",  url) }
    def post(String url)  { request("POST", url) }
    def put (String url)  { request("PUT",  url) }
    def delete(String url){ request("DELETE",url) }

    private request(String method, String url, Closure<?> body = null) {
        def builder = MockMvcRequestBuilders.request(method, url)
                .contentType("application/json")
        if (body) builder.content(JsonOutput.toJson(new JsonBuilder().call(body)))
        this.lastResult = mvc.perform(builder).andReturn()
    }

    def status(int code) {
        lastResult.response.status == code
    }

    def json(body) {
        JsonOutput.prettyPrint(lastResult.response.contentAsString) ==
                JsonOutput.prettyPrint(JsonOutput.toJson(new JsonBuilder().call(body)))
    }
}




(function () {
  const checkInterval = 30000; // 30秒

  async function checkListAndAct() {
    try {
      // 假设你的列表数据可以通过一个 API 获取（替换为实际的接口）
      const response = await fetch('/your-list-api-endpoint'); // ← 替换为你的列表接口
      const list = await response.json();

      // 查找状态为 1 的第一条数据
      const targetItem = list.find(item => item.status === 1); // ← 根据你的字段名调整（如 status / state 等）

      if (targetItem) {
        console.log('发现状态为1的数据:', targetItem);

        // 跳转到详情页（根据你的路由规则构造 URL）
        const detailUrl = `/detail/${targetItem.id}`; // ← 替换为你的详情页 URL 模板
        window.location.href = detailUrl;
        return true; // 停止后续轮询（可选）
      } else {
        console.log('未发现状态为1的数据，30秒后重试...');
      }
    } catch (error) {
      console.error('检查列表时出错:', error);
    }
    return false;
  }

  // 页面加载完成后开始轮询
  if (window.location.pathname === '/your-list-page-path') { // ← 替换为你的列表页路径，例如 '/tasks'
    const intervalId = setInterval(async () => {
      const shouldStop = await checkListAndAct();
      if (shouldStop) {
        clearInterval(intervalId);
      }
    }, checkInterval);

    console.log('已启动状态监测脚本，每30秒检查一次...');
  } else if (window.location.pathname.startsWith('/detail/')) {
    // 如果已经在详情页，尝试自动点击按钮
    const clickButton = () => {
      // 替换为按钮的选择器（例如 class、id 或其他属性）
      const button = document.querySelector('button.confirm-btn'); // ← 替换为实际按钮选择器
      if (button && !button.disabled) {
        button.click();
        console.log('已自动点击按钮');
        return true;
      }
      return false;
    };

    // 立即尝试点击（页面可能已加载）
    if (!clickButton()) {
      // 如果按钮还没加载，等一会儿再试（最多尝试几次）
      let attempts = 0;
      const tryClick = setInterval(() => {
        if (clickButton() || ++attempts >= 10) {
          clearInterval(tryClick);
        }
      }, 1000); // 每秒尝试一次，最多10秒
    }
  }
})();

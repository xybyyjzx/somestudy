@GetMapping("/tree")
public Object getCallTree(@RequestParam(defaultValue = "default") String version) {
    // è·å–æ‰€æœ‰å…¥å£æ–¹æ³•ï¼ˆControllerï¼‰
    List<MethodInfo> entries = methodInfoRepo.findByVersion(version).stream()
        .filter(m -> m.getFullSignature().toLowerCase().contains("controller"))
        .collect(Collectors.toList());

    if (entries.isEmpty()) {
        return Map.of("name", "No Controller Found", "children", Collections.emptyList());
    }

    // æ„å»ºè°ƒç”¨å›¾
    Map<String, Set<String>> callGraph = callEdgeRepo.findByVersion(version).stream()
        .collect(Collectors.groupingBy(
            MethodCallEdge::getCallerSignature,
            Collectors.mapping(MethodCallEdge::getCalleeSignature, Collectors.toSet())
        ));

    // æ„å»ºç­¾å -> MethodInfo æ˜ å°„
    Map<String, MethodInfo> methodMap = methodInfoRepo.findByVersion(version).stream()
        .collect(Collectors.toMap(MethodInfo::getFullSignature, m -> m));

    // é€’å½’æ„å»ºæ ‘ï¼ˆé™åˆ¶æ·±åº¦é¿å…å¾ªç¯ï¼‰
    List<Map<String, Object>> rootChildren = new ArrayList<>();
    for (MethodInfo entry : entries) {
        Map<String, Object> node = buildTreeNode(
            entry.getFullSignature(), 
            methodMap, 
            callGraph, 
            new HashSet<>(), 
            0, 
            5 // æœ€å¤§æ·±åº¦
        );
        if (node != null) rootChildren.add(node);
    }

    return Map.of("name", "Root", "children", rootChildren);
}

private Map<String, Object> buildTreeNode(
    String signature,
    Map<String, MethodInfo> methodMap,
    Map<String, Set<String>> callGraph,
    Set<String> visited,
    int depth,
    int maxDepth
) {
    if (depth > maxDepth || visited.contains(signature)) {
        return null;
    }
    visited.add(signature);

    MethodInfo method = methodInfoRepo.findByFullSignatureAndVersion(signature, "default").orElse(null);
    String name = method != null ? getReadableName(signature) : signature;

    Map<String, Object> node = new HashMap<>();
    node.put("name", name);
    node.put("fullSignature", signature); // ç”¨äºç‚¹å‡»äº‹ä»¶

    Set<String> callees = callGraph.get(signature);
    if (callees != null && !callees.isEmpty()) {
        List<Map<String, Object>> children = new ArrayList<>();
        for (String callee : callees) {
            Map<String, Object> child = buildTreeNode(
                callee, methodMap, callGraph, new HashSet<>(visited), depth + 1, maxDepth
            );
            if (child != null) children.add(child);
        }
        if (!children.isEmpty()) {
            node.put("children", children);
        }
    }

    return node;
}


<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Call Flow Mind Map</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.0/dist/echarts.min.js"></script>
  <style>
    body { margin: 0; padding: 20px; background: #f5f7fa; }
    #chart { width: 100%; height: 800px; background: white; border-radius: 8px; }
    .header { text-align: center; margin-bottom: 15px; }
    button { padding: 6px 12px; margin: 0 5px; }
  </style>
</head>
<body>

<div class="header">
  <h3>ğŸ§  æ–¹æ³•è°ƒç”¨æ€ç»´å¯¼å›¾</h3>
  <button onclick="loadTree('default')">åŠ è½½é»˜è®¤ç‰ˆæœ¬</button>
  <!-- å¯æ·»åŠ ç‰ˆæœ¬è¾“å…¥æ¡† -->
</div>

<div id="chart"></div>

<script>
let currentVersion = 'default';
let chart = echarts.init(document.getElementById('chart'));

function loadTree(version) {
  currentVersion = version;
  fetch(`/api/graph/tree?version=${encodeURIComponent(version)}`)
    .then(res => res.json())
    .then(treeData => {
      const option = {
        tooltip: { trigger: 'item', triggerOn: 'mousemove' },
        series: [{
          type: 'tree',
          orient: 'LR', // ä»å·¦åˆ°å³å¸ƒå±€
          symbolSize: 45,
          label: {
            fontSize: 12,
            color: '#333'
          },
          lineStyle: {
            width: 2,
            color: '#444'
          },
          emphasis: {
            focus: 'descendant'
          },
          expandAndCollapse: true, // å…è®¸æŠ˜å /å±•å¼€
          initialTreeDepth: 2,     // åˆå§‹å±•å¼€2å±‚
           [treeData]
        }]
      };
      chart.setOption(option, true);
    });
}

// ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼ˆæŸ¥çœ‹æºç ï¼‰
chart.on('click', (params) => {
  if (params.data && params.data.fullSignature) {
    const sig = params.data.fullSignature;
    // è°ƒç”¨ä¹‹å‰çš„æºç æŸ¥çœ‹é€»è¾‘
    showMethodDetails(sig);
  }
});

// å¤ç”¨ä¹‹å‰çš„æºç å¼¹çª—ï¼ˆç®€åŒ–ç‰ˆï¼‰
function showMethodDetails(signature) {
  fetch(`/api/graph/source?signature=${encodeURIComponent(signature)}&version=${currentVersion}`)
    .then(res => res.text())
    .then(code => {
      alert(`Source for ${signature}:\n\n${code.substring(0, 500)}...`);
      // å®é™…é¡¹ç›®ä¸­æ›¿æ¢ä¸ºæ¨¡æ€æ¡†
    });
}

// åˆå§‹åŠ è½½
loadTree('default');
</script>

</body>
</html>
